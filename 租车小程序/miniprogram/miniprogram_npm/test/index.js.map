{"version":3,"sources":["test.js","assert.js","utils.js","logger.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar Assert = require(\"./assert\").Assert\nvar Logger = require(\"./logger\").Logger\n\n\nvar ERR_COMPLETED_ASSERT = \"Assert in completed test\"\nvar ERR_COMPLETED_COMPLETE = \"Attemt to complete test more then one times\"\nvar ERR_EXPECT = \"AssertionError\"\n\n\n/**\n * Creates a test function.\n */\nfunction Test(name, unit, logger, Assert) {\n  var isSync = unit.length <= 1\n  var isFailFast = !unit.length\n  var isDone = false\n  return function test(next) {\n    logger = logger.section(name)\n    var assert = Assert(logger)\n    assert.end = function end() {\n      if (isDone) return logger.error(Error(ERR_COMPLETED_COMPLETE))\n      isDone = true\n      next()\n    }\n\n    try {\n      var result = unit(assert, assert.end)\n      // If it\"s async test that returns a promise.\n      if (result && typeof(result.then) === \"function\") {\n        result.then(function passed() {\n          logger.pass(\"passed\")\n          assert.end()\n        }, function failed(reason) {\n          logger.fail(reason)\n          assert.end()\n        })\n      } else {\n        if (isFailFast) logger.pass(\"passed\")\n        if (isSync) assert.end()\n      }\n    } catch (exception) {\n      if (ERR_EXPECT === exception.name) assert.fail(exception)\n      else logger.error(exception)\n      assert.end()\n    }\n  }\n}\n\nfunction isTest(name) { return name.indexOf(\"test\") === 0 }\n\n/**\n * Creates a test suite / group. Calling returned function will execute\n * all test in the given suite.\n */\nfunction Suite(name, units, logger, Assert) {\n  // Collecting properties that represent test functions or suits.\n  var names = Object.keys(units).filter(isTest)\n  Assert = units.Assert || Assert\n  // Returning a function that executes all test in this suite and all it\"s\n  // sub-suits.\n  return function suite(end) {\n    // Chaining test / suits so that each is executed after last is done.\n    function next() {\n      if (!names.length) return end()\n      var name = names.shift()\n      var unit = Unit(name, units[name], logger, units.Assert || Assert)\n      unit(next)\n    }\n    next((logger = logger.section(name)))\n  }\n}\nfunction Unit(name, units, logger, Assert) {\n  return typeof(units) === \"function\" ? Test(name, units, logger, Assert)\n                                      : Suite(name, units, logger, Assert)\n}\n\n\n/**\n * Test runner function.\n */\nexports.run = function run(units, logger) {\n  var exit = logger ? false : true\n  logger = logger || new Logger()\n  var unit = Unit(\"Running all tests:\", units, logger, Assert)\n  unit(function done() {\n    logger.report()\n    var failed = logger.errors.length !== 0 || logger.fails.length !== 0\n    // Exit only if `process.exit` exist and if no logger was provided.\n    if (exit && process.exit) process.exit(failed ? 1 : 0)\n  })\n}\n","\n\nvar utils = require(\"./utils\")\n\n\n/**\n * The `AssertionError` is defined in assert.\n * @extends Error\n * @example\n *  new assert.AssertionError({\n *    message: message,\n *    actual: actual,\n *    expected: expected\n *  })\n */\nfunction AssertionError(options) {\n  var assertionError = Object.create(AssertionError.prototype);\n\n  if (utils.isString(options))\n    options = { message: options };\n  if (\"actual\" in options)\n    assertionError.actual = options.actual;\n  if (\"expected\" in options)\n    assertionError.expected = options.expected;\n  if (\"operator\" in options)\n    assertionError.operator = options.operator;\n\n  assertionError.message = options.message;\n  assertionError.stack = new Error().stack;\n  return assertionError;\n}\nAssertionError.prototype = Object.create(Error.prototype, {\n  constructor: { value: AssertionError },\n  name: { value: \"AssertionError\", enumerable: true },\n  toString: { value: function toString() {\n    var value;\n    if (this.message) {\n      value = this.name + \" : \" + this.message;\n    }\n    else {\n      value = [\n        this.name + \" : \",\n        utils.source(this.expected),\n        this.operator,\n        utils.source(this.actual)\n      ].join(\" \");\n    }\n    return value;\n  }}\n});\nexports.AssertionError = AssertionError;\n\nfunction Assert(logger) {\n  return Object.create(Assert.prototype, { _log: { value: logger }});\n}\nAssert.prototype = {\n  fail: function fail(e) {\n    this._log.fail(e);\n  },\n  pass: function pass(message) {\n    this._log.pass(message);\n  },\n  error: function error(e) {\n    this._log.error(e);\n  },\n  ok: function ok(value, message) {\n    if (!!!value) {\n      this.fail({\n        actual: value,\n        expected: true,\n        message: message,\n        operator: \"==\"\n      });\n    }\n    else {\n      this.pass(message);\n    }\n  },\n\n  /**\n   * The equality assertion tests shallow, coercive equality with `==`.\n   * @example\n   *    assert.equal(1, 1, \"one is one\");\n   */\n  equal: function equal(actual, expected, message) {\n    if (actual == expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"==\"\n      });\n    }\n  },\n\n  /**\n   * The non-equality assertion tests for whether two objects are not equal\n   * with `!=`.\n   * @example\n   *    assert.notEqual(1, 2, \"one is not two\");\n   */\n  notEqual: function notEqual(actual, expected, message) {\n    if (actual != expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"!=\",\n      });\n    }\n  },\n\n  /**\n   * The equivalence assertion tests a deep (with `===`) equality relation.\n   * @example\n   *    assert.deepEqual({ a: \"foo\" }, { a: \"foo\" }, \"equivalent objects\")\n   */\n   deepEqual: function deepEqual(actual, expected, message) {\n    if (isDeepEqual(actual, expected)) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"deepEqual\"\n      });\n    }\n  },\n\n  /**\n   * The non-equivalence assertion tests for any deep (with `===`) inequality.\n   * @example\n   *    assert.notDeepEqual({ a: \"foo\" }, Object.create({ a: \"foo\" }),\n   *                        \"object\"s inherit from different prototypes\");\n   */\n  notDeepEqual: function notDeepEqual(actual, expected, message) {\n    if (!isDeepEqual(actual, expected)) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"notDeepEqual\"\n      });\n    }\n  },\n\n  /**\n   * The strict equality assertion tests strict equality, as determined by\n   * `===`.\n   * @example\n   *    assert.strictEqual(null, null, \"`null` is `null`\")\n   */\n  strictEqual: function strictEqual(actual, expected, message) {\n    if (actual === expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"===\"\n      });\n    }\n  },\n\n  /**\n   * The strict non-equality assertion tests for strict inequality, as\n   * determined by `!==`.\n   * @example\n   *    assert.notStrictEqual(null, undefined, \"`null` is not `undefined`\");\n   */\n  notStrictEqual: function notStrictEqual(actual, expected, message) {\n    if (actual !== expected) {\n      this.pass(message);\n    }\n    else {\n      this.fail({\n        actual: actual,\n        expected: expected,\n        message: message,\n        operator: \"!==\"\n      })\n    }\n  },\n\n  /**\n   * The assertion whether or not given `block` throws an exception. If optional\n   * `Error` argument is provided and it\"s type of function thrown error is\n   * asserted to be an instance of it, if type of `Error` is string then message\n   * of throw exception is asserted to contain it.\n   * @param {Function} block\n   *    Function that is expected to throw.\n   * @param {Error|RegExp} [Error]\n   *    Error constructor that is expected to be thrown or a string that\n   *    must be contained by a message of the thrown exception, or a RegExp\n   *    matching a message of the thrown exception.\n   * @param {String} message\n   *    Description message\n   *\n   * @examples\n   *\n   *    assert.throws(function block() {\n   *      doSomething(4)\n   *    }, \"Object is expected\", \"Incorrect argument is passed\");\n   *\n   *    assert.throws(function block() {\n   *      Object.create(5)\n   *    }, TypeError, \"TypeError is thrown\");\n   */\n  throws: function throws(block, Error, message) {\n    var threw = false;\n    var exception = null;\n\n    // If third argument is not provided and second argument is a string it\n    // means that optional `Error` argument was not passed, so we shift\n    // arguments.\n    if (utils.isString(Error) && utils.isUndefined(message)) {\n      message = Error;\n      Error = undefined;\n    }\n\n    // Executing given `block`.\n    try {\n      block();\n    }\n    catch (e) {\n      threw = true;\n      exception = e;\n    }\n\n    // If exception was thrown and `Error` argument was not passed assert is\n    // passed.\n    if (threw && (utils.isUndefined(Error) ||\n                 // If Error is thrown exception\n                 (Error == exception) ||\n                 // If passed `Error` is RegExp using it\"s test method to\n                 // assert thrown exception message.\n                 (utils.isRegExp(Error) && Error.test(exception.message)) ||\n                 // If passed `Error` is a constructor function testing if\n                 // thrown exception is an instance of it.\n                 (utils.isFunction(Error) && utils.instanceOf(exception, Error))))\n    {\n      this.pass(message);\n    }\n\n    // Otherwise we report assertion failure.\n    else {\n      var failure = {\n        message: message,\n        operator: \"throws\"\n      };\n\n      if (exception)\n        failure.actual = exception;\n\n      if (Error)\n        failure.expected = Error;\n\n      this.fail(failure);\n    }\n  }\n};\nexports.Assert = Assert;\n\nfunction isDeepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  else if (utils.isDate(actual) && utils.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n  }\n\n  // XXX specification bug: this should be specified\n  else if (utils.isPrimitive(actual) || utils.isPrimitive(expected)) {\n    return expected === actual;\n  }\n\n  else if (utils.instanceOf(actual, Error) ||\n           utils.instanceOf(expected, Error)) {\n    return actual.message === expected.message &&\n           actual.type === expected.type &&\n           actual.name === expected.name &&\n           (actual.constructor && expected.constructor &&\n            actual.constructor.name === expected.constructor.name)\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == \"object\",\n  // equivalence is determined by ==.\n  else if (!utils.isObject(actual) && !utils.isObject(expected)) {\n    return actual == expected;\n  }\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \"prototype\" property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  else {\n    return actual.prototype === expected.prototype &&\n           isEquivalent(actual, expected);\n  }\n}\n\nfunction isEquivalent(a, b, stack) {\n  return isArrayEquivalent(Object.keys(a).sort(),\n                           Object.keys(b).sort()) &&\n          Object.keys(a).every(function(key) {\n            return isDeepEqual(a[key], b[key], stack)\n          });\n}\n\nfunction isArrayEquivalent(a, b, stack) {\n  return utils.isArray(a) && utils.isArray(b) && a.length === b.length &&\n         a.every(function(value, index) {\n           return isDeepEqual(value, b[index]);\n         });\n}\n","\n\n/**\n * Returns `true` if `value` is `undefined`.\n * @examples\n *    var foo; isUndefined(foo); // true\n *    isUndefined(0); // false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\nexports.isUndefined = isUndefined;\n\n/**\n * Returns `true` if value is `null`.\n * @examples\n *    isNull(null); // true\n *    isNull(undefined); // false\n */\nfunction isNull(value) {\n  return value === null;\n}\nexports.isNull = isNull;\n\n/**\n * Returns `true` if value is a string.\n * @examples\n *    isString(\"moe\"); // true\n */\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nexports.isString = isString;\n\n/**\n * Returns `true` if `value` is a number.\n * @examples\n *    isNumber(8.4 * 5); // true\n */\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nexports.isNumber = isNumber;\n\n/**\n * Returns `true` if `value` is a `RegExp`.\n * @examples\n *    isRegExp(/moe/); // true\n */\nfunction isRegExp(value) {\n  return instanceOf(value, RegExp);\n}\nexports.isRegExp = isRegExp;\n\n/**\n * Returns true if `value` is a `Date`.\n * @examples\n *    isDate(new Date()); // true\n */\nfunction isDate(value) {\n  return isObject(value) && instanceOf(value, Date);\n}\nexports.isDate = isDate;\n\n/**\n * Returns true if object is a Function.\n * @examples\n *    isFunction(function foo(){}) // true\n */\nfunction isFunction(value) {\n    return typeof value === \"function\" && value.call && value.apply;\n}\nexports.isFunction = isFunction;\n\n/**\n * Returns `true` if `value` is an object (please note that `null` is considered\n * to be an atom and not an object).\n * @examples\n *    isObject({}) // true\n *    isObject(null) // false\n */\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nexports.isObject = isObject;\n\n/**\n * Returns true if `value` is an Array.\n * @examples\n *    isArray([1, 2, 3])  // true\n *    isArray({ 0: \"foo\", length: 1 }) // false\n */\nvar isArray = Array.isArray || function isArray(value) {\n  Object.prototype.toString.call(value) === \"[object Array]\";\n}\nexports.isArray = isArray;\n\n/**\n * Returns `true` if `value` is an Arguments object.\n * @examples\n *    (function(){ return isArguments(arguments); })(1, 2, 3); // true\n *    isArguments([1,2,3]); // false\n */\nfunction isArguments(value) {\n  Object.prototype.toString.call(value) === \"[object Arguments]\";\n}\nexports.isArguments = isArguments;\n\n/**\n * Returns true if it is a primitive `value`. (null, undefined, number,\n * boolean, string)\n * @examples\n *    isPrimitive(3) // true\n *    isPrimitive(\"foo\") // true\n *    isPrimitive({ bar: 3 }) // false\n */\nfunction isPrimitive(value) {\n  return !isFunction(value) && !isObject(value);\n}\nexports.isPrimitive = isPrimitive;\n\n/**\n * Returns `true` if given `object` is flat (it is direct decedent of\n * `Object.prototype` or `null`).\n * @examples\n *    isFlat({}) // true\n *    isFlat(new Type()) // false\n */\nfunction isFlat(object) {\n  return isObject(object) && (isNull(Object.getPrototypeOf(object)) ||\n                              isNull(Object.getPrototypeOf(\n                                     Object.getPrototypeOf(object))));\n}\nexports.isFlat = isFlat;\n\n/**\n * Returns `true` if object contains no values.\n */\nfunction isEmpty(object) {\n  if (isObject(object)) {\n    for (var key in object)\n      return false;\n    return true;\n  }\n  return false;\n}\nexports.isEmpty = isEmpty;\n\n/**\n * Returns `true` if `value` is an array / flat object containing only atomic\n * values and other flat objects.\n */\nfunction isJSON(value, visited) {\n    // Adding value to array of visited values.\n    (visited || (visited = [])).push(value);\n            // If `value` is an atom return `true` cause it\"s valid JSON.\n    return  isPrimitive(value) ||\n            // If `value` is an array of JSON values that has not been visited\n            // yet.\n            (isArray(value) &&  value.every(function(element) {\n                                  return isJSON(element, visited);\n                                })) ||\n            // If `value` is a plain object containing properties with a JSON\n            // values it\"s a valid JSON.\n            (isFlat(value) && Object.keys(value).every(function(key) {\n                var $ = Object.getOwnPropertyDescriptor(value, key);\n                // Check every proprety of a plain object to verify that\n                // it\"s neither getter nor setter, but a JSON value, that\n                // has not been visited yet.\n                return  ((!isObject($.value) || !~visited.indexOf($.value)) &&\n                        !(\"get\" in $) && !(\"set\" in $) &&\n                        isJSON($.value, visited));\n            }));\n}\nexports.isJSON = function (value) {\n  return isJSON(value);\n};\n\n/**\n * Returns if `value` is an instance of a given `Type`. This is exactly same as\n * `value instanceof Type` with a difference that `Type` can be from a scope\n * that has a different top level object. (Like in case where `Type` is a\n * function from different iframe / jetpack module / sandbox).\n */\nfunction instanceOf(value, Type) {\n  var isConstructorNameSame;\n  var isConstructorSourceSame;\n\n  // If `instanceof` returned `true` we know result right away.\n  var isInstanceOf = value instanceof Type;\n\n  // If `instanceof` returned `false` we do ducktype check since `Type` may be\n  // from a different sandbox. If a constructor of the `value` or a constructor\n  // of the value\"s prototype has same name and source we assume that it\"s an\n  // instance of the Type.\n  if (!isInstanceOf && value) {\n    isConstructorNameSame = value.constructor.name === Type.name;\n    isConstructorSourceSame = String(value.constructor) == String(Type);\n    isInstanceOf = (isConstructorNameSame && isConstructorSourceSame) ||\n                    instanceOf(Object.getPrototypeOf(value), Type);\n  }\n  return isInstanceOf;\n}\nexports.instanceOf = instanceOf;\n\n/**\n * Function returns textual representation of a value passed to it. Function\n * takes additional `indent` argument that is used for indentation. Also\n * optional `limit` argument may be passed to limit amount of detail returned.\n * @param {Object} value\n * @param {String} [indent=\"    \"]\n * @param {Number} [limit]\n */\nfunction source(value, indent, limit, offset, visited) {\n  var result;\n  var names;\n  var nestingIndex;\n  var isCompact = !isUndefined(limit);\n\n  indent = indent || \"    \";\n  offset = (offset || \"\");\n  result = \"\";\n  visited = visited || [];\n\n  if (isUndefined(value)) {\n    result += \"undefined\";\n  }\n  else if (isNull(value)) {\n    result += \"null\";\n  }\n  else if (isString(value)) {\n    result += \"\\\"\" + value + \"\\\"\";\n  }\n  else if (isFunction(value)) {\n    value = String(value).split(\"\\n\");\n    if (isCompact && value.length > 2) {\n      value = value.splice(0, 2);\n      value.push(\"...}\");\n    }\n    result += value.join(\"\\n\" + offset);\n  }\n  else if (isArray(value)) {\n    if ((nestingIndex = (visited.indexOf(value) + 1))) {\n      result = \"#\" + nestingIndex + \"#\";\n    }\n    else {\n      visited.push(value);\n\n      if (isCompact)\n        value = value.slice(0, limit);\n\n      result += \"[\\n\";\n      result += value.map(function(value) {\n        return offset + indent + source(value, indent, limit, offset + indent,\n                                        visited);\n      }).join(\",\\n\");\n      result += isCompact && value.length > limit ?\n                \",\\n\" + offset + \"...]\" : \"\\n\" + offset + \"]\";\n    }\n  }\n  else if (isObject(value)) {\n    if ((nestingIndex = (visited.indexOf(value) + 1))) {\n      result = \"#\" + nestingIndex + \"#\"\n    }\n    else {\n      visited.push(value)\n\n      names = Object.keys(value);\n\n      result += \"{ // \" + value + \"\\n\";\n      result += (isCompact ? names.slice(0, limit) : names).map(function(name) {\n        var _limit = isCompact ? limit - 1 : limit;\n        var descriptor = Object.getOwnPropertyDescriptor(value, name);\n        var result = offset + indent + \"// \";\n        var accessor;\n        if (0 <= name.indexOf(\" \"))\n          name = \"\\\"\" + name + \"\\\"\";\n\n        if (descriptor.writable)\n          result += \"writable \";\n        if (descriptor.configurable)\n          result += \"configurable \";\n        if (descriptor.enumerable)\n          result += \"enumerable \";\n\n        result += \"\\n\";\n        if (\"value\" in descriptor) {\n          result += offset + indent + name + \": \";\n          result += source(descriptor.value, indent, _limit, indent + offset,\n                           visited);\n        }\n        else {\n\n          if (descriptor.get) {\n            result += offset + indent + \"get \" + name + \" \";\n            accessor = source(descriptor.get, indent, _limit, indent + offset,\n                              visited);\n            result += accessor.substr(accessor.indexOf(\"{\"));\n          }\n\n          if (descriptor.set) {\n            if (descriptor.get) result += \",\\n\";\n            result += offset + indent + \"set \" + name + \" \";\n            accessor = source(descriptor.set, indent, _limit, indent + offset,\n                              visited);\n            result += accessor.substr(accessor.indexOf(\"{\"));\n          }\n        }\n        return result;\n      }).join(\",\\n\");\n\n      if (isCompact) {\n        if (names.length > limit && limit > 0) {\n          result += \",\\n\" + offset  + indent + \"//...\";\n        }\n      }\n      else {\n        if (names.length)\n          result += \",\";\n\n        result += \"\\n\" + offset + indent + \"\\\"__proto__\\\": \";\n        result += source(Object.getPrototypeOf(value), indent, 0,\n                         offset + indent);\n      }\n\n      result += \"\\n\" + offset + \"}\";\n    }\n  }\n  else {\n    result += String(value);\n  }\n  return result;\n}\nexports.source = function (value, indentation, limit) {\n  return source(value, indentation, limit);\n};\n","\n\nvar font = require(\"ansi-font/index\")\nvar toSource = require(\"./utils\").source\n\nvar INDENT = \"  \"\n\nvar report = console.log.bind(console)\n\nfunction passed(message) {\n  return font.green(\"\\u2713 \" + message)\n}\nfunction failed(message) {\n  return font.red(\"\\u2717 \" + message)\n}\nfunction errored(message) {\n  return font.magenta(\"\\u26A1 \" + message)\n}\n\nfunction indent(message, indentation) {\n  indentation = undefined === indentation ? INDENT : indentation\n  message = message || \"\"\n  return message.replace(/^/gm, indentation)\n}\n\nfunction Logger(options) {\n  if (!(this instanceof Logger)) return new Logger(options)\n\n  options = options || {}\n  var print = options.print || report\n  var indentation = options.indentation || \"\"\n  var results = options.results || { passes: [], fails: [], errors: [] }\n  this.passes = results.passes\n  this.fails = results.fails\n  this.errors = results.errors\n  results = this\n\n\n  this.pass = function pass(message) {\n    results.passes.push(message)\n    print(indent(passed(message), indentation))\n  }\n\n  this.fail = function fail(error) {\n    results.fails.push(error)\n    var message = error.message\n    if (\"expected\" in error)\n      message += \"\\n  Expected: \\n\" + toSource(error.expected, INDENT)\n    if (\"actual\" in error)\n      message += \"\\n  Actual: \\n\" + toSource(error.actual, INDENT)\n    if (\"operator\" in error)\n      message += \"\\n  Operator: \" + toSource(error.operator, INDENT)\n    print(indent(failed(message), indentation))\n  }\n\n  this.error = function error(exception) {\n    results.errors.push(exception)\n    print(indent(errored(exception.stack || exception), indentation))\n  }\n\n  this.section = function section(title) {\n    print(indent(title, indentation))\n    return new Logger({\n      print: print,\n      indentation: indent(indentation),\n      results: results\n    })\n  }\n\n  this.report = function report() {\n    print(\"Passed:\" + results.passes.length +\n          \" Failed:\" + results.fails.length +\n          \" Errors:\" + results.errors.length)\n  }\n}\n\nLogger.Logger = Logger\nmodule.exports = Logger\n"]}